import asyncio
import csv
import logging
import requests
import configparser
from abc import ABC, abstractmethod
from datetime import datetime
from typing import List, Dict, Any
from socket import gethostname

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[logging.FileHandler("sensey.log"), logging.StreamHandler()],
)


class SenseEvent(ABC):
    """Base class for events generated by EnvironmentSensor objects."""

    @abstractmethod
    def reading(self) -> Dict[str, Any]:
        """Returns a dictionary of sensor data."""
        pass


class EnvironmentSensor(ABC):
    """Base class for environment sensors that generate SenseEvents."""

    @abstractmethod
    def poll(self) -> SenseEvent:
        """Polls the sensor and returns a SenseEvent."""
        pass

    @property
    @abstractmethod
    def sensor_names(self) -> List[str]:
        """List of sensor data field names."""
        pass


class CSVLogger:
    """Logs data from EnvironmentSensor objects to a CSV file."""

    def __init__(self, sensors: List["EnvironmentSensor"], interval: int = 300, decimal_places: int = 2):
        """
        Args:
            sensors: List of EnvironmentSensor objects to poll.
            interval: Logging interval in seconds (default: 180s).
            decimal_places: Number of decimal places for floats in the CSV output.
        """
        cfg = configparser.ConfigParser()
        cfg.read('sensey.ini')
        self.sensey_server = "192.168.86.39:5000"
        self.sensors = sensors
        self.interval = interval
        self.decimal_places = decimal_places
        self.host = gethostname()
        self.filename = self._generate_filename()
        if 'client' in cfg:
            self.interval = int( cfg['client']['poll_interval'] )
            self.server_url = cfg['client']['server_url']

    def _generate_filename(self) -> str:
        """Generates a weekly CSV filename based on the current date."""

        datestr = datetime.now().strftime("%Y%m%d")

        return f"{datestr}_{self.host}_sensey_output.csv"

    async def log_data(self):
        """Periodically logs sensor data to a CSV file."""
        while True:
            try:
                logging.info("Polling sensors for data...")
                data = self._poll_sensors()
                self._write_to_csv(data)
                logging.info("Data logged successfully.")
                self._send_data( data )
                logging.info("Data sent to sensey server")
            except Exception as e:
                logging.error(f"Error logging data: {e}", exc_info=True)
            await asyncio.sleep(self.interval)

    def _poll_sensors(self) -> Dict[str, Any]:
        """Polls all sensors and collects their data."""
        consolidated_data = {"timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S")}
        for sensor in self.sensors:
            try:
                event = sensor.poll()
                logging.debug(f"Polled data from {type(sensor).__name__}: {event.reading()}")
                consolidated_data.update(event.reading())
            except Exception as e:
                logging.warning(f"Failed to poll sensor {type(sensor).__name__}: {e}", exc_info=True)

        return consolidated_data

    def _write_to_csv(self, data: Dict[str, Any]):
        """Writes consolidated sensor data to the CSV file."""
        # Generate fieldnames dynamically based on sensor names
        fieldnames = ["timestamp"] + [
            name
            for sensor in self.sensors
            for name in sensor.sensor_names
        ]

        # Prepare the row to write, starting with the timestamp
        row = {}
        for field in fieldnames:  # don't Skip "timestamp"
            value = data.get(field, None)
            if isinstance(value, float):
                value = round(value, self.decimal_places)
            row[field] = value

        # Write to the CSV file
        with open(self.filename, mode='a', newline='') as csvfile:
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)

            # Write the header if the file is empty
            if csvfile.tell() == 0:
                writer.writeheader()

            writer.writerow(row)

    def _send_data( self, data: Dict[str, Any] ):
        """Sends data to a Sensey server """
        
        url = f"http://{self.sensey_server}/data/{self.host}"  # Use hostname to identify the client

        try:
            response = requests.post(url, json=data, timeout=5)
            if response.status_code == 200:
                logging.info("Data sent successfully.")
            else:
                logging.error(f"Server returned an error: {response.status_code} - {response.text}")
                # raise exception
        except requests.RequestException as e:
            print(f"Failed to send data: {e}")

