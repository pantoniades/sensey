import asyncio
import csv
import logging
import requests
import json
import os
import configparser
from abc import ABC, abstractmethod
from collections import deque
from datetime import datetime
from typing import List, Dict, Any, Deque
from socket import gethostname
from time import sleep

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[logging.FileHandler("sensey.log"), logging.StreamHandler()],
)


class SenseEvent(ABC):
    """Base class for events generated by EnvironmentSensor objects."""

    @abstractmethod
    def reading(self) -> Dict[str, Any]:
        """Returns a dictionary of sensor data."""
        pass


class EnvironmentSensor(ABC):
    """Base class for environment sensors that generate SenseEvents."""

    @abstractmethod
    def poll(self) -> SenseEvent:
        """Polls the sensor and returns a SenseEvent."""
        pass

    @property
    @abstractmethod
    def sensor_names(self) -> List[str]:
        """List of sensor data field names."""
        pass


class CSVLogger:
    """Logs data from EnvironmentSensor objects to a CSV file."""

    def __init__(self, sensors: List["EnvironmentSensor"], interval: int = 300, decimal_places: int = 2):
        """
        Args:
            sensors: List of EnvironmentSensor objects to poll.
            interval: Logging interval in seconds (default: 180s).
            decimal_places: Number of decimal places for floats in the CSV output.
        """
        cfg = configparser.ConfigParser()
        cfg.read('sensey.ini')
        self.sensey_server = "192.168.86.39:5000"
        self.sensors = sensors
        self.interval = interval
        self.decimal_places = decimal_places
        self.host = gethostname()
        self.filename = self._generate_filename()
        self.cache_file = "./sensey_cache.json"
        self.INITIAL_RETRY_DELAY = 1
        self.MAX_RETRY_DELAY = 8

        if 'client' in cfg:
            self.interval = int( cfg['client']['poll_interval'] )
            self.sensey_server = cfg['client']['sensey_server']
            self.cache_file = cfg['client']['cache_file']
            self.config = cfg["client"]
            logging.info( f"Loaded config file with keys {self.config.keys()}")
        
        self.cache = self._load_cache()
        self.server_url = f"http://{self.sensey_server}/data/{self.host}"

    def _generate_filename(self) -> str:
        """Generates a weekly CSV filename based on the current date."""

        datestr = datetime.now().strftime("%Y%m%d")

        return f"{datestr}_{self.host}_sensey_output.csv"

    def _save_cache(self):
        """Save unsent data cache to a JSON file."""
        try:
            with open( self.cache_file, "w") as f:
                json.dump(list(self.cache), f)
        except OSError as e:
            logging.error(f"Failed to save unsent data cache: {e}")

    def _load_cache(self) -> Deque[Dict[str, Any]]:
        """Load cached unsent data from a JSON file."""
        cache = deque()
        if os.path.exists(self.cache_file):
            try:
                with open(self.cache_file, "r") as f:
                    data = json.load(f)
                    if isinstance(data, list):
                        cache = deque(data)
            except (json.JSONDecodeError, OSError):
                logging.error("Failed to load unsent data cache. Resetting cache.")
        else:
            logging.info( f"No cache file found at {self.cache_file}")
        return cache
    
    async def log_data(self):
        """Periodically sends data to a sensey_server and logs sensor data to a CSV file."""
        while True:
            try:
                logging.info("Polling sensors for data...")
                data = self._poll_sensors()
                self._write_to_csv(data)
                logging.info("Data logged successfully.")
                self._send_data( data )
                logging.info("Data sent to sensey server")
            except Exception as e:
                logging.error(f"Error logging data: {e}", exc_info=True)
            await asyncio.sleep(self.interval)

    def _poll_sensors(self) -> Dict[str, Any]:
        """Polls all sensors and collects their data."""
        consolidated_data = {"timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S")}
        for sensor in self.sensors:
            try:
                event = sensor.poll()
                logging.debug(f"Polled data from {type(sensor).__name__}: {event.reading()}")
                consolidated_data.update(event.reading())
            except Exception as e:
                logging.warning(f"Failed to poll sensor {type(sensor).__name__}: {e}", exc_info=True)

        return consolidated_data

    def _write_to_csv(self, data: Dict[str, Any]):
        """Writes consolidated sensor data to the CSV file."""
        # Generate fieldnames dynamically based on sensor names
        fieldnames = ["timestamp"] + [
            name
            for sensor in self.sensors
            for name in sensor.sensor_names
        ]

        # Prepare the row to write, starting with the timestamp
        row = {}
        for field in fieldnames:  # don't Skip "timestamp"
            value = data.get(field, None)
            if isinstance(value, float):
                value = round(value, self.decimal_places)
            row[field] = value

        # Write to the CSV file
        with open(self.filename, mode='a', newline='') as csvfile:
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)

            # Write the header if the file is empty
            if csvfile.tell() == 0:
                writer.writeheader()

            writer.writerow(row)

    def _send_data( self, data: Dict[str, Any] ):
        """Sends data to a Sensey server """
        self.cache.append( data )
        self._save_cache()
        retry_delay = self.INITIAL_RETRY_DELAY

        while self.cache:
            current_data = self.cache.popleft()
            success = True
            try:
                response = requests.post( self.server_url, json=data, timeout=5)
                if response.status_code == 200:
                    logging.info("Data sent successfully.")
                    retry_delay = self.INITIAL_RETRY_DELAY
                else:
                    logging.error(f"Server returned an error: {response.status_code} - {response.text}")
                    success = False
            except requests.RequestException as e:
                print(f"Failed to send data: {e}")
                success = False
            finally:
                if success is False:
                    self.cache.appendleft(current_data)
                    logging.warning(f"Unsuccessful send, sleeping for {retry_delay} seconds before trying again")
                    sleep(retry_delay)
                    retry_delay = max( retry_delay*2, self.MAX_RETRY_DELAY )
            self._save_cache()
            if retry_delay == self.MAX_RETRY_DELAY:
                break 

